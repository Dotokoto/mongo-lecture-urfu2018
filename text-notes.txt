CAP теорема
я приведу здесь упрощенные формулировки, чтобы вам было понятнее.
Согласованность означает, что чтение всегда возвращает последнюю запись. То есть не может быть такой ситуации, что вы записали данные,
прочитали их и получили старый вариант.
Доступность означает, что каждый клиент может читать и писать, пока жив хотя бы один узел системы.
Устойчивость к разделению означает, что система продолжает работать корректно при наличии сетевых проблем.
То есть если потерялись пакеты между узлами сети, или даже целый узел отвалился, то данные все равно останутся согласованными и доступными.

Суть утверждения - любая система в один момент времени может обеспечивать только два из трех свойств.

Паттерн выбери два часто используется и в других областях. Например, быстро-качественно-дешево. Выберите два.
SQL базы находятся на ребре CA (consistency-availability). Это означает, что у них есть сложности с разделением.
Реляционные базы данных плохо поддаются горизонтальному масштабированию. Она масштабируется вертикально - можно доьавлять на одну машину
объем памяти, процессор и тд.
Но в вебе часто нужна возможность работать с огромными объемами данных. Поэтому появились и другие системы, которые жертвуют
доступностью или консистентностью ради удобного горизонтального масштабирования.

На ребре CA лежат реляционные бд, на CP в том числе находится mongoDB, которую мы будем изучать. А что на ребре AP?
Там есть например кассандра - колоночная база данных. Там выбираются столбцы. В основном она используется для аналитики и статистике.
Поэтому в вебе AP базы используются редко.

NoSQL - потому что в таких базах используются не sql языки.



Давайте создадим базу данных для приложения "Заметки", которое рассматривалось на предыдущих лекциях.

Create. Создадим нашу первую заметку с помощью команды db.notes.insert. notes здесь - это название коллекции.
В Mongodb одна база данных может содержать несколько коллекций. Коллекция создается автоматически при первом добавлении документа.

Create many. Для создания нескольких документов в инсерт можно передать массив объектов.
В монге схема для данных не обязательна. Поэтому, мы можем добавлять, убирать и менять любые поля в документах.

Схема определяет структуру данных в документах коллекции. Например, мы указываем, что заметка должна обязательно содержать имя и владельца.
И все три поля - это строки.

Попробуем добавить валидную заметку. После добавления в консоль будет выведено сообщение об успешном добавлении одного документа.

В документы можно добавлять поля, не указанные в схеме. Например, добавим заметку про книги и скажем, что это вторая версия заметки.
Поле Версии не было описано в схеме, тем не менее документ успешно добавляется.

Если же мы попытаемся вставить невалидный документ, то получим сообщение об ошибке.

Чтобы прочитать документы из коллекции, существует функция find().
По умолчанию она возвращает в консоль каждый документ в одной строке. Для вывода в более читаемом виде можно вызвать функцию pretty().

Функция find возвращает курсор для обхода коллекции. По умолчанию курсор выдает первые 20 документов.
Если вы хотите получить массив найденных записей, то можно вызвать функцию toArray(). pretty и toArray - это методы курсора.

В возвращенных данных есть поле _id. Хотя мы не добавляли его. Это поле генерируется монгой автоматически при вставке документа и является
его уникальным идентификатором. ObjectID - это особый тип данных в монго.
Для генерации используется текущее время, айди машины, айди процесса и счетчик. Засчет этого значения будут уникальными.

У функции find есть два аргумента. query задает фильтры для выборки. А projection определяет список возвращаемых полей.

В query мы можем задать значение опредленного поля. Например, поискали заметку с названием "Films", и нам вернулась эта заметка.

Вторым параметром можно передать объект, определяющий поля, которые нужно вернуть.
Иногда нам нужны не все поля документа. Передача данных по сети - дорогая операция. Убирая лишние поля, мы ускоряем передачу данных,
а значит и наше приложение.
Например, мы хотим выдать список всех заметок определенного пользователя. Для этого нужны только названия заметок.
Тогда в projection мы указываем только поле name со значением 1.
Но, помимо названия, вернется еще и _id, потому что он всегда включается в выдачу по умолчанию.
Если id нам не нужен, то можно указать в projection поле _id со значением 0, чтобы убрать его из выдачи.

Вернемся снова к первому параметру - query. Можно строить различные условия, используя операторы поиска.
Этот запрос найдет все заметки, у которых версия больше либо равна двум. Список всех операторов можно посмотреть по ссылке.

Можно искать по регулярным выражениям. Синтаксис их такой же, как в javascript. Найдем все заметки, у которых текст начинается со слова
"my", независимо от регистра. У нас в базе сейчас одна такая заметка.

Допустим, у заметок может быть не один владелец, а несколько. Тогда поле owner будет содержать массив имен.

В mongodb внутри документа можно хранить вложенные документы.
Добавим к заметкам поле оценок, которое будет содержать вложенный документ - количество лайков и дизлайков.
При поиске можно указывать путь до поля внутри вложенного объекта через точку. Все точно так же, как в джаваскрипте.


sort, skip, limit

Неважно, в каком порядке мы зададим в запросе эти три модификатора. Всегда будет применяться сначала sort, потом skip, потом limit.

Если вам нужно узнать только количество документов, удовлетворяющих условию, то можно использовать функцию count.
Если вы хотите узнать, сколько всего документов содержит коллекция, то можно вызвать метод count у коллекции.

UPDATE
Искать документы мы научились, теперь давайте научимся обновлять.

Попробуем всем заметкам без версии выставить версию 1. Первый аргумент - условие выборки (все заметки без поля version)
ВТорой аргумент - оператор $set, предназначенный для обновлнеия значений определенных в нем полей.

Выполним запрос, после этого найдем все заметки в базе. Заметим, что поле version выставилось только одной заметке. В еще одной оно уже было.
А в оставшихся двух его нет. Это произошло потому, что update по умолчанию обновляет только один документ.

Если нужно обновить несколько документов, то третьим параметром можно передать опцию multi со значением true.

Кроме set, есть и другие операторы, позволяющие писать запросы в более лаконичном и простом виде.
Если мы хотим инкрементировать номер версии заметки, можно воспользоваться оператором inc.

Для добавления значения в массив есть оператор push. Помните, у нас была заметка с фильмами, у которой было два владельца - Наталья и Анна?
На вечеринку позвали еще Катю, и чтобы дать ей доступ к заметке, добавим ее в массив владельцев с помощью оператора push.

С обновлением закончили.
Последняя операция - удаление документов. Для этого используется функция remove. Первый аргумент - уже знакомый вам query.
Второй - флаг, означающий, что удалить нужно только один документ.
Например, так можно удалить все заметки. А второй способ удалит только одну заметку.

ТРАНЗАКЦИИ

Что делать, если нам нужно обновить сразу несколько документов в разных коллекциях?
Допустим, у нас есть еще коллекция пользователей. И у каждого пользователя есть список его заметок.
Мы хотим удалить заметку о фильмах. Нам понадобится сделать два запроса. Первый удаляет саму заметку, а второй убирает ее из списка заметок.
Что произойдет, если один запрос выполнится, а второй - нет? У пользователя будет висеть заметка, которой на самом деле уже не существует.

Для таких ситуаций очень пригодился бы механизм транзакций. То есть возможность выполнить несколько запросов как атомарную операцию.
Если хотя бы один из запросов не выполнится, то будут отменены все предыдущие.
Так вот, по поводу транзакций в МонгоДБ есть две новости - плохая и хорошая.
Плохая - их нет.
А хорошая новость - они будут в MongoDB версии 4, которую разработчики обещают выпустить летом этого года.

ИНДЕКСЫ

Дальше рассмотрим механизм индексов. Индекс - объект базы данных, создаваемый с целью повышения производительности поиска данных.
Коллекции могут иметь очень большой размер. К тому же MongoDB изначально предназначена для хранения больших объемов данных.

Пусть у нас стало очень много заметок, больше миллиона. Как быстро будет происходить поиск заметок определенного пользователя?

В mongoDB есть операция explain, которая вместо выполнения запроса показывает, как именно он будет выполнятся -
сколько документов будет просмотрено, сколько времени займет выполнение запроса, и так далее. Воспользуемся им.

Мы видим, что при поиске был просмотрен каждый документ коллекции.
Выполнение запроса заняло 389 миллисекунд. Для реального сервиса это очень долго.
В MongoDB можно включить систему отслеживания медленных запросов. И по умолчанию любой запрос, выполнявшийся дольше 100
миллисекунд, считается медленным.

Создадим индекс для коллекции заметок на поле owner. При создании индекса в базе данных создается особая структура данных.
Которая хранит значения полей, на которые навешан индекс, и данные о том, где расположены документы с этими полями.

Попробуем снова поискать все заметки Натальи после создания индекса.
Теперь запрос выполняется за 19 миллисекунд и просматривается только 3 документа.

Важно понимать, что создание индекса - это дорогая операция. Во-первых, индексы занимают место. Во-вторых, они замедляют
операции записи. Поэтому не стоит бездумно навешивать индексы на все поля. Нужно понимать, какие запросы наиболее часты в вашем приложении,
и навешивать индексы на них.

Индекс может быть уникальным. Для создания уникального индекса нужно выставить флаг unique: true.
Тогда на уровне базы данных будет запрещено добавление документов с одинаковым значением поля name.

В индекс можно добавить сразу несколько полей документа. Такой индекс называется составным.
Уникальный составной индекс не позволит добавлять документы с одинаковым значением обоих полей.
Например, такой индекс не позволит одному пользователю создавать заметки с одинаковыми именами.


Индексы применяются также при операциях сортировки. Здесь как раз часто нужны составные индексы.
Чтобы пользователю было проще искать заметки, отсортируем их по названиям.

ПРИДУМАТЬ ПРИМЕР С СОСТАВНЫМ ИНДЕКСОМ


РЕПЛИКАЦИЯ И ШАРДИРОВАНИЕ

На этом мы закончили с изучением команд MongoDB.
Подумаем теперь на тему построения распреленных баз данных.
Вспомним CAP теорему. В ней Mongo относится к классу CP систем. То есть устойчива к сетевым проблемам и данные в ней согласованны,
но могут возникать проблемы с доступностью.



Какие механизмы отвечают за распределение базы на несколько серверов? Первый механизм - это репликация.
То есть дублирование базы данных на нескольких серверах. Репликация схожа с бэкапом, который постоянно обновляется для сохранения
актуальности данных.
В mongoDB репликой называется база данных, продублированная на нескольких серверах. В реплике обязаельно должен быть главный, или праймари,
сервер.


MONGOOSE

что такое odm?

В монгусе работа с коллекцией всегда начинается с создания схемы. В схеме описываются все поля и их типы.
Также в схеме можно указать дефолтные значения для полей, валидаторы. Или преобразования, которые нужно выполнить перед сохранением
поля в базу.
Монгус поддерживает 6 джаваскриптовых типов данных, ObjectID который мы уже изучали. А Mixed - это обозначение для бессхемного поля,
в котором могут хранится любые данные.

В схеме можно задать индексы. Здесь для схемы Пользователя задаем уникальный индекс на поле Имени.

После создания схемы ее можно скомпилировать в модель. Все операции, связанные с базой данных, выполняются через модель.
Создадим первую заметку с помощью модели заметок. Монгус сразу добавляет геттеры и сеттеры для всех полей из схемы.
Особое внимание тут стоит уделить полю Владельца - мы передали строку, но нам возвращается массив.
Так происходит потому, что в схеме мы указали тип поля - массив строк. И Монгус автоматически преобразовал данные в нужгный формат.

Помимо основных полей, можно задавать виртуальные. Они не будут сохранятся в базу, но для них можно задать геттер.
Например, если мы часто хотим выводить имя и версию заметки, можно сделать виртуальное поле nameAndVersion.

Дальше рассмотрим, как выполнять рассмотренные ранее операции с документами с помощью Монгуса.

При вызове конструктора документ не сохраняется автоматически в базу. Для сохранения нужно вызвать функцию save.
Она возвращает промис, и дальше мы можем обработать успешное сохранение или ошибку.

Для поиска документов используется функция find. Она возвращает объект типа query.
К нему мы можем дописывать дополнительные условия поиска с помощью операторов where. Указывать возвращаемые поля с помощью select
select - это аналог projection в базе.
Сам запрос будет выполнен только после вызова метода exec. exec также возвращает промис.
В результате выполнения запроса будет возвращен массив найденных документов или пустой массив, если ничего не найдено.

Этот пример показывает, как мы можем выстраивать цепочки условий, используя знакомые нам операторы sort, limit, skip.

Обновление документов:
Если у вас уже есть нужный документ в приложении, можно у него вызвать метод update.
Если документа еще нет, то можно сначала его найти (например, с помощью метода findById), потом поменять нужные поля и вызвать метод save();
Если нужно обновить сразу несколько документов, то можно вызвать метод update не у экземпляра, а у самой модели.