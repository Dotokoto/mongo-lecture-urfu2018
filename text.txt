Текст лекции

0) Предисловие
Внезапно может случится момент, когда вам понадобиться работать с базами данных
или
Вы уже умеете создавать сервер и фронтенд, остались только базы данных

1) CAP теорема
Существует большое разнообразие баз данных, предназначенных для разных задач. Хочется иметь идеальную базу, но такой нет. Почему нет? Потому что есть CAP теорема. Определены требования к базам данных, из этих требований может выполняться одновременно только 2 из 3.

Вьетнамские флешбеки с SQL

2) MongoDB
В чем особенности? Почему ее часто используют в вебе?
гибкость, горизонтальная масштабируемость, удобно для прототипов, js удобно для веба.

Начнем создавать базу данных студентов. В Mongo документы хранятся в коллекциях.
Добавим первого студента - Ивана. При добавлении первого документа коллекция создается автоматически.
Как я уже говорила, в MongoDB не обязательны схемы. Поэтому добавленный документ никак не влияет на последующие добавляемые документы. Документы внутри одной коллекции не обязаны содержать одинаковые поля. И поля с одинаковыми названиями вовсе не обязаны иметь одинаковый тип данных.

Давайте добавим еще нескольких студентов - однокурсников Ивана. В insert можно передать массив объектов.
Итак, теперь у нас есть Иван, его безымянный одногруппник (или одногруппница), Анна - девушка со странным возврастом, и Барсик с хвостом.
Что же мы получили? (Картинка с мусором)

Чтобы избежать таких ситуаций, стоит все-таки задать для коллекции схему. Удалим коллекцию студентов, делается это с помощью функции drop(). И создадим заново, задав схему. 
В схеме укажем обязательные поля - имя и группу. И зададим типы данных для полей. Имя и группа - это строки. А возраст - число от 1 до 100.
Теперь при создании и модификации документов их содержимое будет проверяться на валидность.
Попробуем заново добавить Ивана - в результате в консоль выведется сообщение о том, что был успешно добавлен один документ. 
Барсику добавим группу, оставим хвост и попробуем добавить его заново. Как вы думаете, что произойдет? Правильный ответ - запись успешно добавится. Не описанные в схеме поля не валидируются.
А при добавлении невалидных данных выведется ошибка.

Мы научились добавлять записи в коллекцию. Теперь попробуем их прочитать. Для этого используется функция find. 
Мы получили две добавленные записи. Но весь документ записан в одной строке, читать неудобно. 
Сделаем красиво, вызвав после find() функцию pretty().
Теперь посмотрим внимательнее на то, что мы получили. Это две отдельных записи, а не массив. Почему так? Потому что функция find возвращает не все найденные документы, а курсор для обхода коллекции. Если курсор не присвоен в переменную, то он автоматически итерируется до 20 раз и печатает первые 20 документов. У курсора есть различные методы, pretty - один из них.
Если вы хотите получить массив всех найденных записей, можно вызвать метод курсора toArray(). При этом все документы будут разом выгружены в память. Так что нужно быть осторожными при вызове этого метода на очень больших коллекциях.

В найденных документах содержится поле _id, которое мы не добавляли. Оно генерируется Монгой автоматически, если не было передано в запросе. Значение id должно быть уникальным в пределах коллекции.

Снова вернемся к чтению. Метод find принимает два объекта - query и projection. Query задает выборку, а projection задает поля, которые нужно вернуть.
Можем найти всех студентов с именем "Иван". Вернется весь документ.
Если хотим получить только имя и группу, то укажем их во втором параметре. Но при этом, вернется еще и id. Так как по умолчанию он всегда возвращается.
Если выводить id не нужно, то в projection нужно указать для него значение 0.

Со временем в нашей базе появилось больше студентов. И хочется делать более сложные выборки. Для этого в MongoDB есть множество операторов. В этом примере мы ищем всех студентов, у которых курс больше или равен 3 и группа не КН-301. Весь список операторов можно посмотреть в документации.

Можно выбирать данные с помощью регулярных выражений. Для этого используется оператор $regex, либо короткая запись. Эти запросы эквиваленты и вернут всех студентов, у которых в названии группы содержится КБ.

Пусть у нас есть вторая коллекция - группы. В поле students задан список имен всех студентов этой группы.
Мы хотим получить список групп, в которых есть студенты с именем Иван. Сделать это можно таким образом.

В течение семестра студентов появились баллы за задачи по верстке и javascript. Поле grades - это вложенный документ. По вложенным документам тоже можно производить поиск. Например, найдем всех студентов, получивших 1 балл за 10 задачу по джаваскрипту. В условии указана цифра 9, так как массивы нумеруются с нуля.

Прошел год, пора переводить студентов на следующий курс.




