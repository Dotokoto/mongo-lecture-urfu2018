Текст лекции

0) Про базы данных
Вы уже умеете разрабатывать фронтенд. Недавно вы также научились делать сервер на Node.js. До полноценного приложения не хватает только работы с базами данных.

Давайте сначала поговорим о том, чего вообще хочется от базы данных. 

... (тут дописать)

1) CAP теорема
Существует большое разнообразие баз данных, предназначенных для разных задач. Хочется иметь идеальную базу, но такой нет. Почему нет? Потому что есть CAP теорема. Определены требования к базам данных, из этих требований может выполняться одновременно только 2 из 3.

Тлен с SQL

javascript+javascript+javascript





2) MongoDB
-----
(это перенести в другое место, после индексов)
В чем особенности? Почему ее часто используют в вебе?
гибкость, горизонтальная масштабируемость, удобно для прототипов, js удобно для веба.
----


Начнем создавать базу данных студентов. В Mongo документы хранятся в коллекциях.
Добавим первого студента - Ивана. При добавлении первого документа коллекция создается автоматически.
Как я уже говорила, в MongoDB не обязательны схемы. Поэтому добавленный документ никак не влияет на последующие добавляемые документы. Документы внутри одной коллекции не обязаны содержать одинаковые поля. И поля с одинаковыми названиями вовсе не обязаны иметь одинаковый тип данных.

Давайте добавим еще нескольких студентов - однокурсников Ивана. В insert можно передать массив объектов.
Итак, теперь у нас есть Иван, его безымянный одногруппник (или одногруппница), Анна - девушка со странным возврастом, и Барсик с хвостом.
Что же мы получили? (Картинка с мусором)

Чтобы избежать таких ситуаций, стоит все-таки задать для коллекции схему. Удалим коллекцию студентов, делается это с помощью функции drop(). И создадим заново, задав схему. 
В схеме укажем обязательные поля - имя и группу. И зададим типы данных для полей. Имя и группа - это строки. А возраст - число от 1 до 100.
Теперь при создании и модификации документов их содержимое будет проверяться на валидность.
Попробуем заново добавить Ивана - в результате в консоль выведется сообщение о том, что был успешно добавлен один документ. 
Барсику добавим группу, оставим хвост и попробуем добавить его заново. Как вы думаете, что произойдет? Правильный ответ - запись успешно добавится. Не описанные в схеме поля не валидируются.
А при добавлении невалидных данных выведется ошибка.

ЧТЕНИЕ

Мы научились добавлять записи в коллекцию. Теперь попробуем их прочитать. Для этого используется функция find. 
Мы получили две добавленные записи. Но весь документ записан в одной строке, читать неудобно. 
Сделаем красиво, вызвав после find() функцию pretty().
Теперь посмотрим внимательнее на то, что мы получили. Это две отдельных записи, а не массив. Почему так? Потому что функция find возвращает не все найденные документы, а курсор для обхода коллекции. Если курсор не присвоен в переменную, то он автоматически итерируется до 20 раз и печатает первые 20 документов. У курсора есть различные методы, pretty - один из них.
Если вы хотите получить массив всех найденных записей, можно вызвать метод курсора toArray(). При этом все документы будут разом выгружены в память. Так что нужно быть осторожными при вызове этого метода на очень больших коллекциях.

В найденных документах содержится поле _id, которое мы не добавляли. Оно генерируется Монгой автоматически, если не было передано в запросе. Значение id должно быть уникальным в пределах коллекции.

Снова вернемся к чтению. Метод find принимает два объекта - query и projection. Query задает выборку, а projection задает поля, которые нужно вернуть.
Можем найти всех студентов с именем "Иван". Вернется весь документ.
Если хотим получить только имя и группу, то укажем их во втором параметре. Но при этом, вернется еще и id. Так как по умолчанию он всегда возвращается.
Если выводить id не нужно, то в projection нужно указать для него значение 0.

Со временем в нашей базе появилось больше студентов. И хочется делать более сложные выборки. Для этого в MongoDB есть множество операторов. В этом примере мы ищем всех студентов, у которых курс больше или равен 3 и группа не КН-301. Весь список операторов можно посмотреть в документации.

Можно выбирать данные с помощью регулярных выражений. Для этого используется оператор $regex, либо короткая запись. Эти запросы эквиваленты и вернут всех студентов, у которых в названии группы содержится КБ.

Пусть у нас есть вторая коллекция - группы. В поле students задан список имен всех студентов этой группы.
Мы хотим получить список групп, в которых есть студенты с именем Иван. Сделать это можно таким образом.

В течение семестра студентов появились баллы за задачи по верстке и javascript. Поле grades - это вложенный документ. По вложенным документам тоже можно производить поиск. Например, найдем всех студентов, получивших 1 балл за 10 задачу по джаваскрипту. В условии указана цифра 9, так как массивы нумеруются с нуля.


UPDATE
На этом с чтением закончим. Разберемся с обновлением документов. Для обновления используется метод update.
Прошел год, пора переводить студентов на следующий курс. Было бы удобно иметь в документе поле с номером курса, но изначально мы о нем не подумали. Это не страшно, его можно добавить с помощью оператора set. Например, выставим всем студентам, у которых номер группы начинается с единицы, первый курс. Если не передать в опциях значение {multi: true}, то будет обновлена только первая найденная запись.

Переведем на следующий курс всех студентов, у которых нет хвостов. Проверить наличие определенного поля можно с помощью оператора exists. Инкрементируем номер курса с помощью оператора $inc. 

Всем студентам с хвостами выставляем флаг отчисления. При этом, остальные студенты не отчислены, и им это поле не нужно. Таким образом мы экономим место на диске, записывая поля только в случае необходимости. У Барсика был хвост, и к сожалению, он тоже отчисляется.

Кто-то отчисляется, а кто-то восстанавливается. Поправим список студентов в соответствии с новыми данными.

Из всех операций осталось только удаление документов из коллекции. Для удаления используется метод remove. В отличие от update, remove по умолчанию удаляет все подходящие под запрос записи. Поэтому, таким запросом можно удалить всех студентов. А таким - удалить какого-нибудь одного студента.


ТРАНЗАКЦИИ

Давайте вернемся к неприятному вопросу об отчислениях. При отчислении нам нужно обновить две записи в разных коллекциях. Что произойдет, если первое обновление выполнится, а второе нет? Возникнет неконсистентность данных. 
Существует механизм, позволяющий избежать таких ситуаций и выполнить либо все запросы, либо не выполнять ничего. Это механизм транзакций.
Так вот. В MongoDB транзакций нет.
Но они будут в версии 4.0.

ИНДЕКСЫ

Без индексов, MongoDB сканирует каждый документ коллекции для выбора тех документов, которые соответствуют запросу. Индекс - специальная структура данных, которая хранит значение определенного поля или набора полей, упорядоченных по значению поля, указанному в индексе.
Индексы ускоряют операции чтения, но замедляют операции вставки, обновления и удаления. Каждый индекс занимает место на диске. Индексы выбираются по популярным запросам.

Давайте на примере посмотрим, зачем нужны индексы и как они ускоряют поиск. 
Найдем всех студентов группы КБ-501 с помощью метода find. В MongoDB есть специальный метод explain, который выводит информацию о том, как будет выполнятся тот или иной запрос. 
У нас в базе 303 студента. В ответе метода explain можно увидеть, что при выполнении нашего запроса все документы коллекции были просмотрены. А возвращен только один.

Попробуем добавить индекс для поля группы. Это делается с помощью метода createIndex(); Цифра 1 означает порядок сортировки - по возрастанию или по убыванию. Для индексов на одно поле порядок не важен.

Снова выполним поиск. Теперь видно, что был просканирован только один документ. На больших коллекциях это существенно ускорит поиск.

Индекс можно сделать уникальынм. В коллекции групп сделаем уникальным имя группы. Попробуем добавить группу КБ-401. Первое добавление произойдет успешно. А при повторном добавлении будет сгенерирована ошибка с указанием коллекции, индекса и дублирующегося ключа.


Индексы могут быть и составными, то есть состоять из нескольких полей. Например, здесь мы упорядочиваем студентов по убыванию номера курса, а внутри курса - по названию группы.

Посмотреть все существующие индексы можно с помощью метода getIndexes(). На поле _id при создании коллекции по умолчанию создается уникальный индекс. 


РЕПЛИКАЦИЯ И ШАРДИРОВАНИЕ

На этом, мы закончили изучать основные функции для работы с базой данных MongoDB. Мы все еще помним, что хотели создать приложение с использованием mongoDB. Как сделать это приложение более надежным? [надежность так себе слово тут....]

Для этого в MongoDB есть механизм репликации. Репликации нужны для обеспечения большей доступности и отказоустойчивости системы. Реплика по смыслу похожа на бэкап - мы храним одни и те же данные на разных серверах. При этом у нас есть главный сервер, и по умолчанию все операции чтения и записи проходят через него. Все обновления документов он рассылает на дополнительные сервера. 
Как обеспечивается доступность системы? Пусть у нас есть реплика из трех серверов. Эти сервера постоянно проверяют состояние друг друга.
Что произойдет, если главный сервер станет недоступен? Вдруг у него перекопали кабель или что-нибудь в таком духе. Два оставшихся сервера замечают это, выбирают новый главный сервер, и система продолжает работать.

Помните, в начале мы говорили про CAP-теорему? Давайте посмотрим, как репликация обеспечивает нам консистентность и устойчивость к разделению. У нас есть несколько серверов, и при отказе одного сервера система продолжает работать. Значит есть устойчивость к разделению. По умолчанию запросы на чтение и запись всегда отправляются в мастер сервер. Все клиенты будут получать данные с мастера, значит есть консистентность. В какой момент мы жертвуем доступностью? Если не будет выбран главный сервер, то система будет доступна только на чтение.

Второй механизм, который позволяет горизонтально масштабировать базы в Mongo - это шардирование.
Простая аналогия для шардирование - это разбиение большой книги на несколько томов. У вас есть сто тысяч страниц. Если их склеить в одну книгу, то эта книга не влезет на полку. А даже если влезет, ее будет тяжело листать и искать нужные страницы.
Шардирование - это, по сути, разбиение большой коллекции на несколько томов, находящихся на разных серверах. По какому критерию документ отправляется в тот или иной шард? Распределение производится на основе ключа шардирования. Ключом может быть неизменяемое поле, которое есть во всех документах коллекции.

Первый подход - шардирование по диапазону. Допустим, мы выбрали поле x в качестве ключа шардирования. Тогда, в зависимости от значения поля, все документы с определенным интервалом x будут попадать в один шард.
Основная проблема такого подхода - неравномерность распределения. Если значения в поле X всегда неотрицательны, но могут быть очень большими, то в третьем шарде будет содержаться намного больше документов. А преимущество - эффективные запросы по интервалам шардирования.

Второй подход - распределение на основе хэш-функции. В этом случае, документы будут более равномерно распределены по всем шардам. Но появится другая проблема, документы из близких диапазонов скорее всего попадут в разные шарды. То есть преимущества и недостатки поменялись местами.



MONGOOSE

Давайте снова вернемся к работе с mongoDB. Мы научились выполнять все необходимые нам действия. Но делали мы это все из консоли базы данных. А для создания приложения хочется делать все то же самое, но через Node.js. Для этого есть класс библиотек - ODM. Сейчас я покажу вам, как работать с одной из таких библиотек - Mongoose. Она позволяет сохранять ваши объекты в документы. И наоборот, получать из базы документы и преобразовывать их для удобной работы с ними в коде приложения.

Устанавливается Mongoose, как любая другая библиотека для ноды - через npm. 
В приложении нужно первым делом подключиться к базе. Для этого вызвать функцию connect. Она возвращает промис. После коннекта к базе можно приступать к дальнейшим действиям.

В Mongoose для работы с коллекцией необходимо создать схему. Надеюсь, вы еще помните преимущества использования схемы, о которых я говорила в начале этой лекции. Создадим ту же самую схему для коллекции студентов, но уже с помощью Mongoose.
В Mongoose схемы более гибко настраиваемы и имеют больше возможностей. Например, можно задать дефолтное значение для поля. Или преобразования, которые будут выполнятся каждый раз перед сохранении объекта в базу. Как в этом примере - будем по умолчанию выставлять студенту первый курс. И название группы преобразовывать в верхний регистр.

Схемы в Mongoose поддерживают 8 типов данных. Большинство типов вам уже знакомы из javascript. Про ObjectId я тоже уже рассказала. 
(что такое Mixed?)

В схеме можно сразу указать, для каких полей нужны индексы. Создадим схему группы с уникальынм индексом на имя группы. 

Для того чтобы работать непосредственно с документами, нам нужно скомпилировать схему в модель. Так мы получим конструктор, создающий экземпляры этой модели. Вся работа с базой данных выполняется через модель.
Скомпилируем модель студента. В Mongoose название модели нужно писать в единственном числе. Документы, созданные с помощью этой модели, будут сохранятся в коллекцию students.

Создадим первый документ с помощью оператора new.


Можно задать модели виртуальные поля. Такое поле можно будет получить с помощью геттера, но оно не будет сохранятся в модель.



